#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Direct Convolution Package
#+PROPERTY: header-args:julia :session *directConvolution_session*  :exports code :eval no-export


#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Plots
using Revise
using DirectConvolution
using J4Org

documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
#+END_SRC

#+RESULTS:

* Introduction
#+INDEX: Test

*Under construction do not use!*

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

using direct (no FFT) methods. 

Eq. \ref{eq:main} has several applications:
- [[id:e51770f6-45da-4051-b6ab-d0835187f438][Savitzky-Golay filters]] 
- [[id:32475da6-a0b9-4103-a58f-04eebdb75785][Undecimated Wavelet Transform]]

* Usage examples

Our dependencies are as follows:

#+BEGIN_SRC julia
using DirectConvolution
using Plots
#+END_SRC

#+RESULTS:

We also need to load a toy signal:
#+BEGIN_SRC julia :results output 
signal=readcsv("./data/signal_1.csv");
#+END_SRC

#+RESULTS:

For the moment we ignore the first column (X-axis) and only consider Y-values

#+BEGIN_SRC julia :results output 
signal=signal[:,2];
#+END_SRC

#+RESULTS:

** Savitzky-Golay filters
   :PROPERTIES:
   :ID:       e51770f6-45da-4051-b6ab-d0835187f438
   :END:

Creates a set of Savitzky-Golay filters, window width is $11=2*5+1$ and polynomial degree is $3$.

#+BEGIN_SRC julia 
sg = SG_Filter(Float64,halfWidth=5,degree=3);
#+END_SRC

#+RESULTS:

This can be checked with

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
length(sg)
polynomialOrder(sg)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
11
3
#+END_SRC

Savitzky-Golay filters can be used to smooth or to compute smoothed
derivatives of a signal. The associated filter is obtained thanks to
the =filter= function.

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
filter(sg,derivativeOrder=2)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
DirectConvolution.LinearFilter_DefaultCentered{Float64,11}([0.034965, 0.013986, -0.002331, -0.013986, -0.020979, -0.02331, -0.020979, -0.013986, -0.002331, 0.013986, 0.034965])
#+END_SRC

Maximum derivative order is equal to the polynomial order, however there is a dedicated function:

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
maxDerivativeOrder(sg)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
3
#+END_SRC


Smoothing example:

#+BEGIN_SRC julia
smoothed=directConv(filter(sg,derivativeOrder=0),signal,ConstantBE,ConstantBE)

plot(signal,label="signal")
plot!(smoothed, label="smoothed",linewidth=2)
plot!(signal-smoothed, label="residue")
#+END_SRC

#+RESULTS:


#+BEGIN_SRC julia :results graphics :file figures/sg.png :exports results
savefig("figures/sg.png")
#+END_SRC

#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothing
#+RESULTS:
[[file:figures/sg.png]]


Smoothed first order derivative example:

#+BEGIN_SRC julia
smoothed_d1 = directConv(filter(sg,derivativeOrder=1),signal)

plot(signal,label="signal")
plot!(smoothed_d1, label="smoothed derivative",linewidth=2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia :results graphics :file figures/sg_d1.png :exports results
savefig("figures/sg_d1.png")
#+END_SRC


#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothed first order derivative
#+RESULTS:
[[file:figures/sg_d1.png]]


** Undecimated Wavelet Transform
   :PROPERTIES:
   :ID:       32475da6-a0b9-4103-a58f-04eebdb75785
   :END:
   
* API documentation

** Linear Filter

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="LinearFilter",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<f0tLmGHo>> *Index:* *[E]* [[9xFLmkxr][export]] *[F]* [[aPIXBEvQ][fcoef]] *[L]* [[cCuot7P0][length]], [[pIIf46Xt][LinearFilter]], [[QjuGjDGJ][LinearFilter_Default]], [[a0PFP5qa][LinearFilter_DefaultCentered]] *[O]* [[9OvrBFzN][offset]] *[R]* [[9jORZ3UE][range]] 
- @@latex:\phantomsection@@ *=export=*  <<9xFLmkxr>>
#+BEGIN_SRC julia :eval never :exports code
export LinearFilter,LinearFilter_Default, LinearFilter_CenteredDefault,
    fcoef, length, offset, range
#+END_SRC
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::1][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=fcoef=*  <<aPIXBEvQ>>
#+BEGIN_SRC julia :eval never :exports code
fcoef(c::LinearFilter)
#+END_SRC
#+BEGIN_QUOTE
Returns filter coefficients as a Vector type 
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::13][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=length=*  <<cCuot7P0>>
#+BEGIN_SRC julia :eval never :exports code
length(c::LinearFilter)
#+END_SRC
#+BEGIN_QUOTE
Returns filter length
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::16][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=LinearFilter=*  <<pIIf46Xt>>
#+BEGIN_SRC julia :eval never :exports code
abstract type LinearFilter{T<:Number} 
#+END_SRC
#+BEGIN_QUOTE
Abstract type defining a linear filter
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::8][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=LinearFilter_Default=*  <<QjuGjDGJ>>
#+BEGIN_SRC julia :eval never :exports code
struct LinearFilter_Default{T<:AbstractFloat,N} <: LinearFilter{T}
#+END_SRC
#+BEGIN_QUOTE
Default linear filter
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::36][linearFilter.jl]], [[f0tLmGHo][back to index]]
#+BEGIN_SRC julia :eval never :exports code
function LinearFilter_Default(c::AbstractArray{T,1},offset::Int)  where {T<:AbstractFloat}
#+END_SRC
#+BEGIN_QUOTE
Creates a linear filter from a coefficient vector and its associated offset
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::43][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=LinearFilter_DefaultCentered=*  <<a0PFP5qa>>
#+BEGIN_SRC julia :eval never :exports code
struct LinearFilter_DefaultCentered{T<:AbstractFloat,N} <: LinearFilter{T}
#+END_SRC
#+BEGIN_QUOTE
Provides a default implementation of size 2n+1, with offset = n

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::52][linearFilter.jl]], [[f0tLmGHo][back to index]]
#+BEGIN_SRC julia :eval never :exports code
function LinearFilter_DefaultCentered(c::Array{T}) where {T<:AbstractFloat}
#+END_SRC
#+BEGIN_QUOTE
Creates a centered linear filter from an array of size = 2n+1

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::59][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=offset=*  <<9OvrBFzN>>
#+BEGIN_SRC julia :eval never :exports code
offset(c::LinearFilter)
#+END_SRC
#+BEGIN_QUOTE
Returns filter offset
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::19][linearFilter.jl]], [[f0tLmGHo][back to index]]
#+BEGIN_SRC julia :eval never :exports code
offset(f::LinearFilter_DefaultCentered{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Returns offset, if size = 2n+1 then offset = n

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::68][linearFilter.jl]], [[f0tLmGHo][back to index]]
- @@latex:\phantomsection@@ *=range=*  <<9jORZ3UE>>
#+BEGIN_SRC julia :eval never :exports code
range(c::LinearFilter)
#+END_SRC
#+BEGIN_QUOTE
Returns filter range
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::22][linearFilter.jl]], [[f0tLmGHo][back to index]]
:END:

** Undecimated Wavelet Transform

*** UDWT Filters
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="UDWT_Filter",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<U4eMskWj>> *Index:* *[E]* [[zNIMz45A][export]] *[T]* [[WyqdU4vG][tildeϕ_filter]], [[qh3InRc5][tildeϕ_offset]], [[9Ev62wzN][tildeψ_filter]], [[rOtmMIoc][tildeψ_offset]] *[U]* [[zjgkGc3g][UDWT_Filter]], [[wA6vxrEf][UDWT_Filter_Biorthogonal]], [[9f4Iuq4S][UDWT_Filter_Haar]], [[LK1k53lr][UDWT_Filter_Starck2]] *[Φ]* [[z87CV6IX][ϕ_filter]], [[MhNJRITS][ϕ_offset]] *[Ψ]* [[syHub6Hr][ψ_filter]], [[RdJBlioM][ψ_offset]] 
 - @@latex:\phantomsection@@ *=export=*  <<zNIMz45A>>
 #+BEGIN_SRC julia :eval never :exports code
 export UDWT_Filter_Haar, UDWT_Filter_Starck2
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::1][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 export ϕ_filter,ψ_filter,tildeϕ_filter,tildeψ_filter,ϕ_offset,ψ_offset,tildeϕ_offset,tildeψ_offset
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::3][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=tildeϕ_filter=*  <<WyqdU4vG>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::23][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::46][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=tildeϕ_offset=*  <<qh3InRc5>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_offset(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::31][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_offset(c::UDWT_Filter)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::50][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=tildeψ_filter=*  <<9Ev62wzN>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::25][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::48][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=tildeψ_offset=*  <<rOtmMIoc>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_offset(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::33][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_offset(c::UDWT_Filter)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::52][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter=*  <<zjgkGc3g>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter{T<:Number} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 A specialization of UDWT_Filter_Biorthogonal for *orthogonal* filters.


 For orthogonal filters we have: $\phi=\tilde{\phi}$ and $\psi=\tilde{\psi}$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::36][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Biorthogonal=*  <<wA6vxrEf>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter_Biorthogonal{T<:Number} 
 #+END_SRC
 #+BEGIN_QUOTE
 Abstract type defining the $\phi$, $\psi$, $\tilde{\phi}$ and
 $\tilde{\psi}$ filters associated to an undecimated biorthogonal
 wavelet transform

 - [ ] TODO must use LinearFilter struct
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::10][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Haar=*  <<9f4Iuq4S>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Haar{T<:AbstractFloat} <: UDWT_Filter{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Haar filter
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::57][udwt.jl]], [[U4eMskWj][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 UDWT_Filter_Haar{T}() where {T<:Real}
 #+END_SRC
 #+BEGIN_QUOTE
 Inner constructor
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::65][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Starck2=*  <<LK1k53lr>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Starck2{T<:AbstractFloat} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Starck2 filter

 Defined by Eq. 6 from http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4060954
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::75][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=ϕ_filter=*  <<z87CV6IX>>
 #+BEGIN_SRC julia :eval never :exports code
 ϕ_filter(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::19][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=ϕ_offset=*  <<MhNJRITS>>
 #+BEGIN_SRC julia :eval never :exports code
 ϕ_offset(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::27][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=ψ_filter=*  <<syHub6Hr>>
 #+BEGIN_SRC julia :eval never :exports code
 ψ_filter(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::21][udwt.jl]], [[U4eMskWj][back to index]]
 - @@latex:\phantomsection@@ *=ψ_offset=*  <<RdJBlioM>>
 #+BEGIN_SRC julia :eval never :exports code
 ψ_offset(c::UDWT_Filter_Biorthogonal)
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::29][udwt.jl]], [[U4eMskWj][back to index]]
 :END:

*** UDWT Computational subroutines
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag="UDWT",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 <<Oou521Tf>> *Index:* *[I]* [[vFVTfVsf][inverse_udwt]], [[CjsihxFm][inverse_udwt!]] *[L]* [[ud5ZKljn][length]] *[S]* [[ZjybEwvU][scale]] *[U]* [[IB0jWrJV][UDWT]], [[h0Ziwuvo][udwt]] 
 - @@latex:\phantomsection@@ *=inverse_udwt=*  <<vFVTfVsf>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt(udwt_domain::UDWT{T})::Array{T,1} where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Returns:* a vector containing the reconstructed signal.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::242][udwt.jl]], [[Oou521Tf][back to index]]
 - @@latex:\phantomsection@@ *=inverse_udwt!=*  <<CjsihxFm>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt!(udwt_domain::UDWT{T},reconstructed_signal::AbstractArray{T,1}) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Caveat:* uses a pre-allocated vector =reconstructed_signal=
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::183][udwt.jl]], [[Oou521Tf][back to index]]
 - @@latex:\phantomsection@@ *=length=*  <<ud5ZKljn>>
 #+BEGIN_SRC julia :eval never :exports code
 length(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns initial signal length
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::117][udwt.jl]], [[Oou521Tf][back to index]]
 - @@latex:\phantomsection@@ *=scale=*  <<ZjybEwvU>>
 #+BEGIN_SRC julia :eval never :exports code
 scale(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns max scale
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::114][udwt.jl]], [[Oou521Tf][back to index]]
 - @@latex:\phantomsection@@ *=UDWT=*  <<IB0jWrJV>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT{T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 A structure to store 1D UDWT
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::95][udwt.jl]], [[Oou521Tf][back to index]]
 - @@latex:\phantomsection@@ *=udwt=*  <<h0Ziwuvo>>
 #+BEGIN_SRC julia :eval never :exports code
 function udwt(signal::AbstractArray{T,1},filter::UDWT_Filter_Biorthogonal{T};scale::Int=3) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D undecimated wavelet transform

 $$(\mathcal{W}_{j+1}f)[u]=(\bar{g}_j*\mathcal{V}_{j}f)[u]$$
 $$(\mathcal{V}_{j+1}f)[u]=(\bar{h}_j*\mathcal{V}_{j}f)[u]$$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::121][udwt.jl]], [[Oou521Tf][back to index]]
 :END:

** Convolution functions

These are the main functions of the package, allowing to compute Eq. \ref{eq:main}.

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="Convolution",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<2RHeFXyE>> *Index:* *[D]* [[n0vikZyY][directConv]], [[7S2h3kwp][directConv!]] 
 - @@latex:\phantomsection@@ *=directConv=*  <<n0vikZyY>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv(tilde_α::AbstractArray{T,1},
		     α_offset::Int64,
		     λ::Int64,

		     β::AbstractArray{T,1},

		     ::Type{LeftBE}=ZeroPaddingBE,
		     ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Returns γ, a created vector of length identical to β one.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::242][directConvolution.jl]], [[2RHeFXyE][back to index]]
 - @@latex:\phantomsection@@ *=directConv!=*  <<7S2h3kwp>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv!(tilde_α::AbstractArray{T,1},
		      α_offset::Int,
		      λ::Int,

		      β::AbstractArray{T,1},

		      γ::AbstractArray{T,1},
		      Ωγ::UnitRange{Int},

		      ::Type{LeftBE}=ZeroPaddingBE,
		      ::Type{RightBE}=ZeroPaddingBE;

		      accumulate::Bool=false) where {T <: Number,
						     LeftBE <: BoundaryExtension,
						     RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Inplace modification of γ
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::164][directConvolution.jl]], [[2RHeFXyE][back to index]]
 #+BEGIN_SRC julia :eval never :exports code
 function directConv!(α::LinearFilter{T},
		      λ::Int,

		      β::AbstractArray{T,1},

		      γ::AbstractArray{T,1},
		      Ωγ::UnitRange{Int},

		      ::Type{LeftBE}=ZeroPaddingBE,
		      ::Type{RightBE}=ZeroPaddingBE;

		      accumulate::Bool=false) where {T <: Number,
						     LeftBE <: BoundaryExtension,
						     RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Takes a filter as input 

 Inplace modification of γ
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::202][directConvolution.jl]], [[2RHeFXyE][back to index]]
 :END:

* TODO [0/1]
- [ ] add example with derivative taking X into account

