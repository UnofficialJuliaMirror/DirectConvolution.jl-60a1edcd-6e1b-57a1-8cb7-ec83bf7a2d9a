#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Direct Convolution Package
#+PROPERTY: header-args:julia :session *directConvolution_session*  :exports code :eval no-export
#+LATEX_HEADER: \usepackage{stmaryrd}

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Revise
using DirectConvolution
using J4Org

initialize_boxing_module(usedModules=["DirectConvolution"])
#+END_SRC

#+RESULTS:

* Introduction

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

using direct (no FFT) methods. 

* API documentation
** Linear Filter

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="LinearFilter",tag_to_ignore="Internal",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

ERROR: MethodError: no method matching print_org_doc(::Array{J4Org.Documented_Item,1}; tag="LinearFilter", tag_to_ignore="Internal", header_level=0)
Closest candidates are:
  print_org_doc(::Array{J4Org.Documented_Item,1}; tag, identifier, header_level, link_prefix, complete_link, case_sensitive, boxingModule) at /home/picaud/GitLab/PVBibliography/Julia/MyLocalPackages/J4Org/src/main.jl:371 got unsupported keyword argument "tag_to_ignore"
Stacktrace:
 [1] (::J4Org.#kw##print_org_doc)(::Array{Any,1}, ::J4Org.#print_org_doc, ::Array{J4Org.Documented_Item,1}) at ./<missing>:0
:END:


** Convolution functions

These are the main functions of the package, allowing to compute Eq. \ref{eq:main}.

*** Boundary extensions

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="BoundaryExtension",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<DBvcbdNU>> *Index:* *[B]* [[HPuv7Y6L][BoundaryExtension]] *[C]* [[P9hSEyJ5][ConstantBE]] *[M]* [[NlHjKfzk][MirrorBE]] *[P]* [[59X8dWEW][PeriodicBE]] *[Z]* [[9ALJON6Z][ZeroPaddingBE]] *[b]* [[iS10tLrK][boundaryExtension]] *[c]* [[hFYnSayM][compute_Ωγ1]] *[r]* [[b0z5Axer][relativeComplement_left]], [[q3DObmcL][relativeComplement_right]] *[s]* [[aOpeXe2L][scale]] 
 - @@latex:\phantomsection@@ *=BoundaryExtension=*  <<HPuv7Y6L>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type BoundaryExtension 
 #+END_SRC
 #+BEGIN_QUOTE
 Used for tag dispatching, parent of available boundary extensions

 #+BEGIN_SRC julia
 subtypes(BoundaryExtension)
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC julia
 4-element Array{Union{DataType, UnionAll},1}:
  DirectConvolution.ConstantBE   
  DirectConvolution.MirrorBE     
  DirectConvolution.PeriodicBE   
  DirectConvolution.ZeroPaddingBE
 #+END_SRC

 #+RESULTS:

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::11][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=ConstantBE=*  <<P9hSEyJ5>>
 #+BEGIN_SRC julia :eval never :exports code
 struct ConstantBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::21][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=MirrorBE=*  <<NlHjKfzk>>
 #+BEGIN_SRC julia :eval never :exports code
 struct MirrorBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::25][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=PeriodicBE=*  <<59X8dWEW>>
 #+BEGIN_SRC julia :eval never :exports code
 struct PeriodicBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::23][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=ZeroPaddingBE=*  <<9ALJON6Z>>
 #+BEGIN_SRC julia :eval never :exports code
 struct ZeroPaddingBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::19][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=boundaryExtension=*  <<iS10tLrK>>
 #+BEGIN_SRC julia :eval never :exports code
 function boundaryExtension(β::AbstractArray{T,1},
			    k::Int,
			    ::Type{ZeroPaddingBE}) where {T <: Number}
 #+END_SRC
 #+BEGIN_QUOTE
 #+BEGIN_SRC julia
 r=-5:10
 hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,ZeroPaddingBE),r))'
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC julia
 -5:10
 2×16 Array{Int64,2}:
  -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
   0   0   0   0   0  0  1  2  3  0  0  0  0  0  0   0
 #+END_SRC

 #+RESULTS:
 | -5 |
 | -4 |
 | -3 |
 | -2 |
 | -1 |
 |  0 |
 |  1 |
 |  2 |
 |  3 |
 |  4 |
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::109][directConvolution.jl]], [[DBvcbdNU][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function boundaryExtension(β::AbstractArray{T,1},
			    k::Int,
			    ::Type{ConstantBE}) where {T <: Number}
 #+END_SRC
 #+BEGIN_QUOTE
 #+BEGIN_SRC julia
 r=-5:10
 hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,ConstantBE),r))'
 #+END_SRC

 #+RESULTS:
 | -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
 |  1 |  1 |  1 |  1 |  1 | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |  3 |

 #+BEGIN_SRC julia
 -5:10
 2×16 Array{Int64,2}:
  -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
   1   1   1   1   1  1  1  2  3  3  3  3  3  3  3   3
 #+END_SRC

 #+RESULTS:
 | -5 |
 | -4 |
 | -3 |
 | -2 |
 | -1 |
 |  0 |
 |  1 |
 |  2 |
 |  3 |
 |  4 |
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::127][directConvolution.jl]], [[DBvcbdNU][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function boundaryExtension(β::AbstractArray{T,1},
			    k::Int,
			    ::Type{PeriodicBE}) where {T <: Number}
 #+END_SRC
 #+BEGIN_QUOTE
 #+BEGIN_SRC julia
 r=-5:10
 hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,PeriodicBE),r))'
 #+END_SRC

 #+RESULTS:
 | -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
 |  1 |  2 |  3 |  1 |  2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 |  1 |

 #+BEGIN_SRC julia
 -5:10
 2×16 Array{Int64,2}:
  -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
   1   2   3   1   2  3  1  2  3  1  2  3  1  2  3   1
 #+END_SRC

 #+RESULTS:
 | -5 |
 | -4 |
 | -3 |
 | -2 |
 | -1 |
 |  0 |
 |  1 |
 |  2 |
 |  3 |
 |  4 |
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::147][directConvolution.jl]], [[DBvcbdNU][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function boundaryExtension(β::AbstractArray{T,1},
			    k::Int,
			    ::Type{MirrorBE}) where {T <: Number}
 #+END_SRC
 #+BEGIN_QUOTE
 #+BEGIN_SRC julia
 r=-5:10
 hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,MirrorBE),r))'
 #+END_SRC

 #+RESULTS:
 | -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
 |  3 |  2 |  1 |  2 |  3 | 2 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 |  2 |

 #+BEGIN_SRC julia
 -5:10
 2×16 Array{Int64,2}:
  -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
   3   2   1   2   3  2  1  2  3  2  1  2  3  2  1   2
 #+END_SRC

 #+RESULTS:
 | -5 |
 | -4 |
 | -3 |
 | -2 |
 | -1 |
 |  0 |
 |  1 |
 |  2 |
 |  3 |
 |  4 |
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::161][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=compute_Ωγ1=*  <<hFYnSayM>>
 #+BEGIN_SRC julia :eval never :exports code
 function compute_Ωγ1(Ωα::UnitRange{Int},
		      λ::Int,
		      Ωβ::UnitRange{Int})
 #+END_SRC
 #+BEGIN_QUOTE
 In
 $$
 \gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
 $$
 the computation of $\gamma[k],\ k\in\Omega^\gamma$ is splitted into two parts:  
  - one part $\Omega^\gamma \cap \Omega^\gamma_1$ *free of boundary effect*,  
  - one part $\Omega^\gamma \setminus \Omega^\gamma_1$ *that requires boundary extension* $\tilde{\beta}=\Phi(\beta,k)$

 *Example:*
 #+BEGIN_SRC julia
 DirectConvolution.compute_Ωγ1(-1:2,-2,1:20)
 #+END_SRC

 #+RESULTS:
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |
 | 11 |
 | 12 |
 | 13 |
 | 14 |
 | 15 |
 | 16 |
 | 17 |
 | 18 |

 #+BEGIN_SRC julia
 5:18
 #+END_SRC

 #+RESULTS:
 |  5 |
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |
 | 11 |
 | 12 |
 | 13 |
 | 14 |
 | 15 |
 | 16 |
 | 17 |
 | 18 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::47][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=relativeComplement_left=*  <<b0z5Axer>>
 #+BEGIN_SRC julia :eval never :exports code
 function relativeComplement_left(A::UnitRange{Int},
				  B::UnitRange{Int})
 #+END_SRC
 #+BEGIN_QUOTE
 Left relative complement

 $$
 (A\setminus B)_{\text{Left}}=[  l(A), \min{(u(A),l(B)-1)} ]
 $$

 *Example:*
 #+BEGIN_SRC julia
 DirectConvolution.relativeComplement_left(1:10,-5:5)
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC julia
 1:0
 #+END_SRC

 #+RESULTS:

 $(A\setminus B)=\{6,7,8,9,10\}$ and the left part (elements that are
 $\in A$ but on the left side of $B$) is *empty*.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::69][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=relativeComplement_right=*  <<q3DObmcL>>
 #+BEGIN_SRC julia :eval never :exports code
 function relativeComplement_right(A::UnitRange{Int},
				   B::UnitRange{Int})
 #+END_SRC
 #+BEGIN_QUOTE
 Left relative complement

 $$
 (A\setminus B)_{\text{Right}}=[ \max{(l(A),u(B)+1)}, u(A) ]
 $$

 *Example:*
 #+BEGIN_SRC julia
 DirectConvolution.relativeComplement_right(1:10,-5:5)
 #+END_SRC

 #+RESULTS:
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 #+BEGIN_SRC julia
 6:10
 #+END_SRC

 #+RESULTS:
 |  6 |
 |  7 |
 |  8 |
 |  9 |
 | 10 |

 $(A\setminus B)=\{6,7,8,9,10\}$ and the right part (elements that are
 $\in A$ but on the right side of $B$) are $\{6,7,8,9,10\}$
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::88][directConvolution.jl]], [[DBvcbdNU][back to index]]
 - @@latex:\phantomsection@@ *=scale=*  <<aOpeXe2L>>
 #+BEGIN_SRC julia :eval never :exports code
 function scale(λ::Int,Ω::UnitRange{Int})
 #+END_SRC
 #+BEGIN_QUOTE
 Range scaling

 *Caveat:*
 We do not use Julia =scale= function as it returns a step range:
 #+BEGIN_SRC julia
 r=6:8
 -2*r
 #+END_SRC

 #+RESULTS:
 | -12 |
 | -14 |
 | -16 |

 #+BEGIN_SRC julia
 6:8
 -12:-2:-16
 #+END_SRC

 #+RESULTS:
 | -12 |
 | -14 |
 | -16 |

 What we need is:
 #+BEGIN_SRC julia
 scale(-2,r)
 #+END_SRC

 #+RESULTS:
 | -16 |
 | -15 |
 | -14 |
 | -13 |
 | -12 |

 #+BEGIN_SRC julia
 -16:-12
 #+END_SRC

 #+RESULTS:
 | -16 |
 | -15 |
 | -14 |
 | -13 |
 | -12 |

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::30][directConvolution.jl]], [[DBvcbdNU][back to index]]
 :END:

*** Convolution computation

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="Convolution",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 # =WARNING:= Link target ("range_filter", "") not found
 <<slzeaQwS>> *Index:* *[d]* [[lOEhAGkS][directConv]], [[sJfVbO2Q][directConv!]], [[h8dZdFvp][directCrossCorrelation]] *[f]* [[3aOvHErS][filter_range]] 
 - @@latex:\phantomsection@@ *=directConv=*  <<lOEhAGkS>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv(α::LinearFilter{T},

		     λ::Int64,

		     β::AbstractArray{T,1},

		     ::Type{LeftBE}=ZeroPaddingBE,
		     ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Convenience function that allocate $\gamma$ and compute all its
 component using [[ViF3ZWjsdirectConv_details][directConv!(...)]]

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.

 *Example:*
 #+BEGIN_SRC julia
 β=[1:15;];
 γ=ones(Int,15);
 α=LinearFilter([0,0,1],0);
 γ=directConv(α,1,β);
 hcat([1:length(γ);],γ)'
 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |  0 |  0 |

 #+BEGIN_SRC julia
 2×15 Array{Int64,2}:
  1  2  3  4  5  6  7   8   9  10  11  12  13  14  15
  3  4  5  6  7  8  9  10  11  12  13  14  15   0   0
 #+END_SRC

 #+RESULTS:

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::296][directConvolution.jl]], [[slzeaQwS][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function directConv(α::LinearFilter{T},
		     β::AbstractArray{T,1},

		     ::Type{LeftBE}=ZeroPaddingBE,
		     ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 This is a convenience function where $\lambda=-1$

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::342][directConvolution.jl]], [[slzeaQwS][back to index]]
 - @@latex:\phantomsection@@ *=directConv!=*  <<sJfVbO2Q>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv!(tilde_α::AbstractArray{T,1},
		      α_offset::Int,
		      λ::Int,
		      β::AbstractArray{T,1},
		      γ::AbstractArray{T,1},
		      Ωγ::UnitRange{Int},
		      ::Type{LeftBE}=ZeroPaddingBE,
		      ::Type{RightBE}=ZeroPaddingBE;
		      accumulate::Bool=false)::Void where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::178][directConvolution.jl]], [[slzeaQwS][back to index]]
  @@latex:\phantomsection@@  <<ViF3ZWjsdirectConv_details>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv!(α::LinearFilter{T},
		      λ::Int,

		      β::AbstractArray{T,1},

		      γ::AbstractArray{T,1},
		      Ωγ::UnitRange{Int},

		      ::Type{LeftBE}=ZeroPaddingBE,
		      ::Type{RightBE}=ZeroPaddingBE;

		      accumulate::Bool=false)::Void where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Inplace modification of $\gamma[k], k\in\Omega_\gamma$.
 $$
 \gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
 $$
 If $k\notin \Omega_\gamma$, $\gamma[k]$ is unmodified.

 If *accumulate=false* then an erasing step $\gamma[k]=0,
 k\in\Omega_\gamma$ is performed before computation.

 If $\lambda=-1$ you compute a convolution, if $\lambda=+1$ you
 compute a cross-correlation.

 *Example:*
 #+BEGIN_SRC julia
 β=[1:15;];
 γ=ones(Int,15);
 α=LinearFilter([0,0,1],0);
 directConv!(α,1,β,γ,5:10);
 hcat([1:length(γ);],γ)'
 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
 | 1 | 1 | 1 | 1 | 7 | 8 | 9 | 10 | 11 | 12 |  1 |  1 |  1 |  1 |  1 |

 #+BEGIN_SRC julia
 2×15 Array{Int64,2}:
  1  2  3  4  5  6  7   8   9  10  11  12  13  14  15
  1  1  1  1  7  8  9  10  11  12   1   1   1   1   1
 #+END_SRC

 #+RESULTS:

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::239][directConvolution.jl]], [[slzeaQwS][back to index]]
 - @@latex:\phantomsection@@ *=directCrossCorrelation=*  <<h8dZdFvp>>
 #+BEGIN_SRC julia :eval never :exports code
 function directCrossCorrelation(α::LinearFilter{T},
				 β::AbstractArray{T,1},

				 ::Type{LeftBE}=ZeroPaddingBE,
				 ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
								       LeftBE <: BoundaryExtension,
								       RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a cross-correlation 

 This is a convenience function where $\lambda=+1$

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::361][directConvolution.jl]], [[slzeaQwS][back to index]]
 - @@latex:\phantomsection@@ *=filter_range=*  <<3aOvHErS>>
 #+BEGIN_SRC julia :eval never :exports code
 filter_range(size::Int,offset::Int)::UnitRange
 #+END_SRC
 #+BEGIN_QUOTE
 Computes _range_filter_ using primitive types.
 This allows reuse by =directConv!= for instance.

 *Caveat:* do not overload Base.range !!! 
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::28][linearFilter.jl]], [[slzeaQwS][back to index]]
 :END:

** Undecimated Wavelet Transform
*** UDWT Filters
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="UDWT_Filter",header_level=0,case_sensitive=true)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<7BnhuQ2F>> *Index:* *[U]* [[Jae42X9U][UDWT_Filter]], [[WF7MErCJ][UDWT_Filter_Biorthogonal]], [[wtgho0b4][UDWT_Filter_Haar]], [[7H2mLxMl][UDWT_Filter_Starck2]] *[e]* [[XZsXs0xY][export]] *[t]* [[5LC0YRE7][tildeψ_filter]], [[QEdBHBeO][tildeψ_offset]], [[2E7yElGR][tildeϕ_filter]], [[j6Ec9PMt][tildeϕ_offset]] *[ψ]* [[NnkcTr1o][ψ_filter]], [[3asoLeoj][ψ_offset]] *[ϕ]* [[Fhnsu5gi][ϕ_filter]], [[TvdyJlt1][ϕ_offset]] 
 - @@latex:\phantomsection@@ *=UDWT_Filter=*  <<Jae42X9U>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter{T<:Number} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 A specialization of UDWT_Filter_Biorthogonal for *orthogonal* filters.


 For orthogonal filters we have: $\phi=\tilde{\phi}$ and $\psi=\tilde{\psi}$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::40][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Biorthogonal=*  <<WF7MErCJ>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter_Biorthogonal{T<:Number} 
 #+END_SRC
 #+BEGIN_QUOTE
 Abstract type defining the $\phi$, $\psi$, $\tilde{\phi}$ and
 $\tilde{\psi}$ filters associated to an undecimated biorthogonal
 wavelet transform

 - [X] TODO must use LinearFilter struct 
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::12][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Haar=*  <<wtgho0b4>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Haar{T<:AbstractFloat} <: UDWT_Filter{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Haar filter
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::66][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT_Filter_Haar{T}() where {T<:Real}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::72][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Starck2=*  <<7H2mLxMl>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Starck2{T<:AbstractFloat} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Starck2 filter

 Defined by Eq. 6 from http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4060954
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::80][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT_Filter_Starck2{T}() where {T<:Real}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::90][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=export=*  <<XZsXs0xY>>
 #+BEGIN_SRC julia :eval never :exports code
 export UDWT_Filter_Haar, UDWT_Filter_Starck2
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::1][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 export ϕ_filter,ψ_filter,tildeϕ_filter,tildeψ_filter,ϕ_offset,ψ_offset,tildeϕ_offset,tildeψ_offset
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::3][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=tildeψ_filter=*  <<5LC0YRE7>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::27][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::53][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=tildeψ_offset=*  <<QEdBHBeO>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_offset(c::UDWT_Filter_Biorthogonal)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::35][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_offset(c::UDWT_Filter)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::59][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=tildeϕ_filter=*  <<2E7yElGR>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::25][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::50][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=tildeϕ_offset=*  <<j6Ec9PMt>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_offset(c::UDWT_Filter_Biorthogonal)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::33][udwt.jl]], [[7BnhuQ2F][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_offset(c::UDWT_Filter)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::56][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=ψ_filter=*  <<NnkcTr1o>>
 #+BEGIN_SRC julia :eval never :exports code
 ψ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::23][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=ψ_offset=*  <<3asoLeoj>>
 #+BEGIN_SRC julia :eval never :exports code
 ψ_offset(c::UDWT_Filter_Biorthogonal)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::31][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=ϕ_filter=*  <<Fhnsu5gi>>
 #+BEGIN_SRC julia :eval never :exports code
 ϕ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::21][udwt.jl]], [[7BnhuQ2F][back to index]]
 - @@latex:\phantomsection@@ *=ϕ_offset=*  <<TvdyJlt1>>
 #+BEGIN_SRC julia :eval never :exports code
 ϕ_offset(c::UDWT_Filter_Biorthogonal)::Int
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::29][udwt.jl]], [[7BnhuQ2F][back to index]]
 :END:

*** UDWT Computational subroutines
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag="UDWT",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 <<r1zggBFD>> *Index:* *[U]* [[SlruEqZm][UDWT]] *[e]* [[B2Qr33u6][export]] *[i]* [[EDa7ChXh][inverse_udwt]], [[EqC7v1ze][inverse_udwt!]] *[l]* [[jTnzQULM][length]] *[s]* [[PMTbdxyV][scale]] *[u]* [[4gR8g5kq][udwt]] 
 - @@latex:\phantomsection@@ *=UDWT=*  <<SlruEqZm>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT{T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 A structure to store 1D UDWT
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::99][udwt.jl]], [[r1zggBFD][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT{T}(filter::UDWT_Filter_Biorthogonal{T};
	     n::Int=0,
	     scale::Int=0) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance

 *Parameters:*
 - *filter*: used filter
 - *scale* : max scale
 - *n*: signal length
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::110][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=export=*  <<B2Qr33u6>>
 #+BEGIN_SRC julia :eval never :exports code
 export udwt, scale, inverse_udwt!, inverse_udwt
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::5][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=inverse_udwt=*  <<EDa7ChXh>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt(udwt_domain::UDWT{T})::Array{T,1} where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Returns:* a vector containing the reconstructed signal.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::250][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=inverse_udwt!=*  <<EqC7v1ze>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt!(udwt_domain::UDWT{T},reconstructed_signal::AbstractArray{T,1}) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Caveat:* uses a pre-allocated vector =reconstructed_signal=
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::193][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=length=*  <<jTnzQULM>>
 #+BEGIN_SRC julia :eval never :exports code
 length(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns expected signal length
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::129][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=scale=*  <<PMTbdxyV>>
 #+BEGIN_SRC julia :eval never :exports code
 scale(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns max scale
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::126][udwt.jl]], [[r1zggBFD][back to index]]
 - @@latex:\phantomsection@@ *=udwt=*  <<4gR8g5kq>>
 #+BEGIN_SRC julia :eval never :exports code
 function udwt(signal::AbstractArray{T,1},filter::UDWT_Filter_Biorthogonal{T};scale::Int=3) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D undecimated wavelet transform

 $$(\mathcal{W}_{j+1}f)[u]=(\bar{g}_j*\mathcal{V}_{j}f)[u]$$
 $$(\mathcal{V}_{j+1}f)[u]=(\bar{h}_j*\mathcal{V}_{j}f)[u]$$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::133][udwt.jl]], [[r1zggBFD][back to index]]
 :END:




* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("/home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl")
#+END_SRC

#+RESULTS:
: Test Summary:     | Pass  Total
: DirectConvolution |   39     39


