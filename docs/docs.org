#+SETUPFILE: ./Setup/setupFile.org
#+TITLE: Direct Convolution Package
#+PROPERTY: header-args:julia :session *directConvolution_session*  :exports code :eval no-export
#+LATEX_HEADER: \usepackage{stmaryrd}

#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[]{
  bgcolor=bg,
  breaklines=true,
  breakanywhere=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

#+BEGIN_SRC julia :exports none
using Revise
using DirectConvolution
using J4Org

initialize_boxing_module(usedModules=["DirectConvolution"])
#+END_SRC

#+RESULTS:

* Introduction

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

#+ATTR_HTML: :align center :width 600px
[[file:figures/a_offset.png]]

using direct (no FFT) methods. 

* API documentation
** Linear Filter

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="LinearFilter",tag_to_ignore="Internal",header_level=0)
#+END_SRC

#+RESULTS:
:RESULTS:

<<eHagNvk0>> *Index:* *[L]* [[TG7lF5vE][LinearFilter]] *[f]* [[mZYDB4Sy][fcoef]] *[l]* [[nuSC9KZF][length]] *[o]* [[dIkziyfE][offset]] *[r]* [[JedjqqKz][range]] 
- @@latex:\phantomsection@@ *=LinearFilter=*  <<TG7lF5vE>> <<GqitrcdfLinearFilter>>
#+BEGIN_SRC julia :eval never :exports code
abstract type LinearFilter{T<:Number} 
#+END_SRC
#+BEGIN_QUOTE
Abstract type defining a linear filter. A linear filter is defined by its coefficients and by its domain
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::7][linearFilter.jl:7]], [[eHagNvk0][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function LinearFilter(c::AbstractArray{T,1},offset::Int)::LinearFilter  where {T}
#+END_SRC
#+BEGIN_QUOTE
Creates a linear filter from its coefficients and an offset

The *offset* is the position of the filter coefficient to be aligned with zero, see [[Gqitrcdfrange_filter][range(...)]].

*Example:*
#+BEGIN_SRC julia
f=LinearFilter([0:5;],4);
hcat([range(f);],fcoef(f))
#+END_SRC
#+BEGIN_SRC julia
6×2 Array{Int64,2}:
 -4  0
 -3  1
 -2  2
 -1  3
  0  4
  1  5
#+END_SRC
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::104][linearFilter.jl:104]], [[eHagNvk0][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function LinearFilter(c::AbstractArray{T,1})::LinearFilter  where {T}
#+END_SRC
#+BEGIN_QUOTE
Creates a centered linear filter, it must have an odd number of
coefficients, $2n+1$ and is centered by construction (offset=n)

*Example:*
#+BEGIN_SRC julia
f=LinearFilter([0:4;]);
hcat([range(f);],fcoef(f))
#+END_SRC
#+BEGIN_SRC julia
5×2 Array{Int64,2}:
 -2  0
 -1  1
  0  2
  1  3
  2  4
#+END_SRC
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::118][linearFilter.jl:118]], [[eHagNvk0][back to index]]
- @@latex:\phantomsection@@ *=fcoef=*  <<mZYDB4Sy>>
#+BEGIN_SRC julia :eval never :exports code
fcoef(c::LinearFilter)
#+END_SRC
#+BEGIN_QUOTE
Returns filter coefficients
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::13][linearFilter.jl:13]], [[eHagNvk0][back to index]]
- @@latex:\phantomsection@@ *=length=*  <<nuSC9KZF>>
#+BEGIN_SRC julia :eval never :exports code
length(c::LinearFilter)::Int
#+END_SRC
#+BEGIN_QUOTE
Returns filter length
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::17][linearFilter.jl:17]], [[eHagNvk0][back to index]]
- @@latex:\phantomsection@@ *=offset=*  <<dIkziyfE>>
#+BEGIN_SRC julia :eval never :exports code
offset(c::LinearFilter)::Int
#+END_SRC
#+BEGIN_QUOTE
Returns filter offset

*Caveat:* the first position is *0* (and not *1*)

See: [[Gqitrcdfrange_filter][range(...)]]
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::20][linearFilter.jl:20]], [[eHagNvk0][back to index]]
- @@latex:\phantomsection@@ *=range=*  <<JedjqqKz>> <<Gqitrcdfrange_filter>>
#+BEGIN_SRC julia :eval never :exports code
range(c::LinearFilter)::UnitRange
#+END_SRC
#+BEGIN_QUOTE
Returns filter range $\Omega$

Filter support is defined by
$$
\Omega_\alpha = [ -\text{offset}(\alpha) , \text{size}(\alpha) -\text{offset}(\alpha)  - 1 ]
$$
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::36][linearFilter.jl:36]], [[eHagNvk0][back to index]]
:END:

** Convolution functions

These are the main functions of the package, allowing to compute Eq. \ref{eq:main}.

*** Boundary extensions

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="BoundaryExtension",tag_to_ignore="Internal",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<zaN0QWGv>> *Index:* *[B]* [[GSQrUL7D][BoundaryExtension]] *[C]* [[OQbAHA9f][ConstantBE]] *[M]* [[LbSAKucY][MirrorBE]] *[P]* [[vJupDWIk][PeriodicBE]] *[Z]* [[Wx6GMbhf][ZeroPaddingBE]] 
 - @@latex:\phantomsection@@ *=BoundaryExtension=*  <<GSQrUL7D>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type BoundaryExtension 
 #+END_SRC
 #+BEGIN_QUOTE
 Used for tag dispatching, parent of available boundary extensions

 #+BEGIN_SRC julia
 subtypes(BoundaryExtension)
 #+END_SRC
 #+BEGIN_SRC julia
 4-element Array{Union{DataType, UnionAll},1}:
  DirectConvolution.ConstantBE   
  DirectConvolution.MirrorBE     
  DirectConvolution.PeriodicBE   
  DirectConvolution.ZeroPaddingBE
 #+END_SRC
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::11][directConvolution.jl:11]], [[zaN0QWGv][back to index]]
 - @@latex:\phantomsection@@ *=ConstantBE=*  <<OQbAHA9f>>
 #+BEGIN_SRC julia :eval never :exports code
 struct ConstantBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::21][directConvolution.jl:21]], [[zaN0QWGv][back to index]]
 - @@latex:\phantomsection@@ *=MirrorBE=*  <<LbSAKucY>>
 #+BEGIN_SRC julia :eval never :exports code
 struct MirrorBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::25][directConvolution.jl:25]], [[zaN0QWGv][back to index]]
 - @@latex:\phantomsection@@ *=PeriodicBE=*  <<vJupDWIk>>
 #+BEGIN_SRC julia :eval never :exports code
 struct PeriodicBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::23][directConvolution.jl:23]], [[zaN0QWGv][back to index]]
 - @@latex:\phantomsection@@ *=ZeroPaddingBE=*  <<Wx6GMbhf>>
 #+BEGIN_SRC julia :eval never :exports code
 struct ZeroPaddingBE <: BoundaryExtension
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::19][directConvolution.jl:19]], [[zaN0QWGv][back to index]]
 :END:

*** Convolution computation

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="Convolution",tag_to_ignore="Internal",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<3lvRpUaq>> *Index:* *[d]* [[lJyVkY7N][directConv]], [[HIlHMDah][directConv!]], [[JFO9W4zA][directConv2D!]], [[Wt9IX0LL][directCrossCorrelation]], [[DzCOJeWI][directCrossCorrelation2D]] 
 - @@latex:\phantomsection@@ *=directConv=*  <<lJyVkY7N>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv(α::LinearFilter{T},

		     λ::Int64,

		     β::AbstractArray{T,1},

		     ::Type{LeftBE}=ZeroPaddingBE,
		     ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Convenience function that allocate $\gamma$ and compute all its
 component using [[TAy1pwnGdirectConv_details][directConv!(...)]]

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.

 *Example:*
 #+BEGIN_SRC julia
 β=[1:15;];
 γ=ones(Int,15);
 α=LinearFilter([0,0,1],0);
 γ=directConv(α,1,β);
 hcat([1:length(γ);],γ)'
 #+END_SRC
 #+BEGIN_SRC julia
 2×15 Array{Int64,2}:
  1  2  3  4  5  6  7   8   9  10  11  12  13  14  15
  3  4  5  6  7  8  9  10  11  12  13  14  15   0   0
 #+END_SRC
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::296][directConvolution.jl:296]], [[3lvRpUaq][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 function directConv(α::LinearFilter{T},
		     β::AbstractArray{T,1},

		     ::Type{LeftBE}=ZeroPaddingBE,
		     ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 This is a convenience function where $\lambda=-1$

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::342][directConvolution.jl:342]], [[3lvRpUaq][back to index]]
 - @@latex:\phantomsection@@ *=directConv!=*  <<HIlHMDah>> <<TAy1pwnGdirectConv_details>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv!(α::LinearFilter{T},
		      λ::Int,

		      β::AbstractArray{T,1},

		      γ::AbstractArray{T,1},
		      Ωγ::UnitRange{Int},

		      ::Type{LeftBE}=ZeroPaddingBE,
		      ::Type{RightBE}=ZeroPaddingBE;

		      accumulate::Bool=false)::Void where {T <: Number,
							   LeftBE <: BoundaryExtension,
							   RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a convolution.

 Inplace modification of $\gamma[k], k\in\Omega_\gamma$.
 $$
 \gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
 $$
 If $k\notin \Omega_\gamma$, $\gamma[k]$ is unmodified.

 If *accumulate=false* then an erasing step $\gamma[k]=0,
 k\in\Omega_\gamma$ is performed before computation.

 If $\lambda=-1$ you compute a convolution, if $\lambda=+1$ you
 compute a cross-correlation.

 *Example:*
 #+BEGIN_SRC julia
 β=[1:15;];
 γ=ones(Int,15);
 α=LinearFilter([0,0,1],0);
 directConv!(α,1,β,γ,5:10);
 hcat([1:length(γ);],γ)'
 #+END_SRC
 #+BEGIN_SRC julia
 2×15 Array{Int64,2}:
  1  2  3  4  5  6  7   8   9  10  11  12  13  14  15
  1  1  1  1  7  8  9  10  11  12   1   1   1   1   1
 #+END_SRC
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::239][directConvolution.jl:239]], [[3lvRpUaq][back to index]]
 - @@latex:\phantomsection@@ *=directConv2D!=*  <<JFO9W4zA>> <<TAy1pwnGdirectConv2D_inplace>>
 #+BEGIN_SRC julia :eval never :exports code
 function directConv2D!(α_I::LinearFilter{T},
			λ_I::Int,
			α_J::LinearFilter{T},
			λ_J::Int,

			β::AbstractArray{T,2},

			::Type{min_I_BE}=ZeroPaddingBE,
			::Type{max_I_BE}=ZeroPaddingBE,
			::Type{min_J_BE}=ZeroPaddingBE,
			::Type{max_J_BE}=ZeroPaddingBE)::Void where {T <: Number,
								     min_I_BE <: BoundaryExtension,
								     max_I_BE <: BoundaryExtension,
								     min_J_BE <: BoundaryExtension,
								     max_J_BE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a 2D (separable) convolution.

 For general information about parameters, see [[TAy1pwnGdirectConv_details][directConv!(...)]]

 α_I must be interpreted as filter for *running index I*

 CAVEAT: the result overwrites β

 TODO: @parallel
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::384][directConvolution.jl:384]], [[3lvRpUaq][back to index]]
 - @@latex:\phantomsection@@ *=directCrossCorrelation=*  <<Wt9IX0LL>>
 #+BEGIN_SRC julia :eval never :exports code
 function directCrossCorrelation(α::LinearFilter{T},
				 β::AbstractArray{T,1},

				 ::Type{LeftBE}=ZeroPaddingBE,
				 ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
								       LeftBE <: BoundaryExtension,
								       RightBE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a cross-correlation 

 This is a convenience function where $\lambda=+1$

 *Returns:* $\gamma$ a created vector of length identical to the $\beta$ one.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::361][directConvolution.jl:361]], [[3lvRpUaq][back to index]]
 - @@latex:\phantomsection@@ *=directCrossCorrelation2D=*  <<DzCOJeWI>>
 #+BEGIN_SRC julia :eval never :exports code
 function directCrossCorrelation2D(α_I::LinearFilter{T},
				   α_J::LinearFilter{T},

				   β::AbstractArray{T,2},

				   ::Type{min_I_BE}=ZeroPaddingBE,
				   ::Type{max_I_BE}=ZeroPaddingBE,
				   ::Type{min_J_BE}=ZeroPaddingBE,
				   ::Type{max_J_BE}=ZeroPaddingBE)::Array{T,2} where {T <: Number,
										      min_I_BE <: BoundaryExtension,
										      max_I_BE <: BoundaryExtension,
										      min_J_BE <: BoundaryExtension,
										      max_J_BE <: BoundaryExtension}
 #+END_SRC
 #+BEGIN_QUOTE
 Computes a 2D cross-correlation

 This is a wrapper that calls [[TAy1pwnGdirectConv2D_inplace][directConv2D!(...)]]

 *Note:* β is not modified, instead the function returns the result.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::459][directConvolution.jl:459]], [[3lvRpUaq][back to index]]
 :END:

** Savitzky-Golay Filters
   :PROPERTIES:
   :ID:       b3e33804-4140-43be-a3eb-7dc02be41876
   :END:
#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="SG_Filters",tag_to_ignore="Internal",header_level=0,link_prefix="API_")
#+END_SRC

#+RESULTS:
:RESULTS:

<<hbEfGuFa>> *Index:* *[S]* [[2hv1BPSi][SG_Filter]] *[a]* [[owTkbNcL][apply_SG_filter]], [[Lam5dNLq][apply_SG_filter2D]] *[f]* [[UGxjZxqz][filter]] *[l]* [[NkIzu2Ct][length]] *[m]* [[424qByXJ][maxDerivativeOrder]] *[p]* [[g7niCxYf][polynomialOrder]] 
- @@latex:\phantomsection@@ *=SG_Filter=*  <<2hv1BPSi>>
#+BEGIN_SRC julia :eval never :exports code
struct SG_Filter{T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
A structure to store Savitzky-Golay filters.
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::30][SG_Filter.jl:30]], [[hbEfGuFa][back to index]]
 @@latex:\phantomsection@@  <<API_SG_Filters_Constructor>>
#+BEGIN_SRC julia :eval never :exports code
function SG_Filter(T::DataType=Float64;halfWidth::Int=5,degree::Int=2)::SG_Filter
#+END_SRC
#+BEGIN_QUOTE
Creates a set of Savitzky-Golay filters

- filter length is 2*halfWidth+1
- polynomial degree is degree
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::58][SG_Filter.jl:58]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=apply_SG_filter=*  <<owTkbNcL>>
#+BEGIN_SRC julia :eval never :exports code
function apply_SG_filter(signal::Array{T,1},
                         sg::SG_Filter{T};
                         derivativeOrder::Int=0) where {T<:AbstractFloat}
#+END_SRC
#+BEGIN_QUOTE
Applies SG filter to 1D signal
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::87][SG_Filter.jl:87]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=apply_SG_filter2D=*  <<Lam5dNLq>>
#+BEGIN_SRC julia :eval never :exports code
function apply_SG_filter2D(signal::Array{T,2},
                           sg_I::SG_Filter{T},
                           sg_J::SG_Filter{T};
                           derivativeOrder_I::Int=0,
                           derivativeOrder_J::Int=0) where {T<:AbstractFloat}
#+END_SRC
#+BEGIN_QUOTE
Applies SG filter to 2D signal
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::101][SG_Filter.jl:101]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=filter=*  <<UGxjZxqz>>
#+BEGIN_SRC julia :eval never :exports code
function filter(sg::SG_Filter{T,N};derivativeOrder::Int=0) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Returns the filter to be used to compute the  smoothed derivatives of order *derivativeOrder*.
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::37][SG_Filter.jl:37]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=length=*  <<NkIzu2Ct>>
#+BEGIN_SRC julia :eval never :exports code
length(sg::SG_Filter{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Returns filter length, this is an odd number, see [[API_SG_Filters_Constructor][SG_Filter(...)]]
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::45][SG_Filter.jl:45]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=maxDerivativeOrder=*  <<424qByXJ>>
#+BEGIN_SRC julia :eval never :exports code
maxDerivativeOrder(sg::SG_Filter{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Maximum order of the smoothed derivatives we can compute with *sg*
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::49][SG_Filter.jl:49]], [[hbEfGuFa][back to index]]
- @@latex:\phantomsection@@ *=polynomialOrder=*  <<g7niCxYf>>
#+BEGIN_SRC julia :eval never :exports code
polynomialOrder(sg::SG_Filter{T,N}) where {T<:AbstractFloat,N}
#+END_SRC
#+BEGIN_QUOTE
Returns the degree of the polynomial used to construct the Savitzky-Golay filters, see [[API_SG_Filters_Constructor][SG_Filter(...)]].
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/SG_Filter.jl::54][SG_Filter.jl:54]], [[hbEfGuFa][back to index]]
:END:

** Undecimated Wavelet Transform
*** UDWT Filters
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="UDWT_Filter",tag_to_ignore="Internal",header_level=0,case_sensitive=true)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<FfZly5es>> *Index:* *[U]* [[B7GLcSCs][UDWT_Filter]], [[cQJAjFOX][UDWT_Filter_Biorthogonal]] *[t]* [[2DNnbjtm][tildeψ_filter]], [[lGYTgOw4][tildeϕ_filter]] *[ψ]* [[6VXdOudS][ψ_filter]] *[ϕ]* [[oWutf3W9][ϕ_filter]] 
 - @@latex:\phantomsection@@ *=UDWT_Filter=*  <<B7GLcSCs>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter{T<:Number} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 A specialization of UDWT_Filter_Biorthogonal for *orthogonal* filters.


 For orthogonal filters we have: $\phi=\tilde{\phi}$ and $\psi=\tilde{\psi}$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::27][udwt.jl:27]], [[FfZly5es][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Biorthogonal=*  <<cQJAjFOX>>
 #+BEGIN_SRC julia :eval never :exports code
 abstract type UDWT_Filter_Biorthogonal{T<:Number} 
 #+END_SRC
 #+BEGIN_QUOTE
 Abstract type defining the $\phi$, $\psi$, $\tilde{\phi}$ and
 $\tilde{\psi}$ filters associated to an undecimated biorthogonal
 wavelet transform
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::9][udwt.jl:9]], [[FfZly5es][back to index]]
 - @@latex:\phantomsection@@ *=tildeψ_filter=*  <<2DNnbjtm>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::22][udwt.jl:22]], [[FfZly5es][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeψ_filter(c::UDWT_Filter)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::40][udwt.jl:40]], [[FfZly5es][back to index]]
 - @@latex:\phantomsection@@ *=tildeϕ_filter=*  <<lGYTgOw4>>
 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::20][udwt.jl:20]], [[FfZly5es][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 tildeϕ_filter(c::UDWT_Filter)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::37][udwt.jl:37]], [[FfZly5es][back to index]]
 - @@latex:\phantomsection@@ *=ψ_filter=*  <<6VXdOudS>>
 #+BEGIN_SRC julia :eval never :exports code
 ψ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::18][udwt.jl:18]], [[FfZly5es][back to index]]
 - @@latex:\phantomsection@@ *=ϕ_filter=*  <<oWutf3W9>>
 #+BEGIN_SRC julia :eval never :exports code
 ϕ_filter(c::UDWT_Filter_Biorthogonal)::LinearFilter
 #+END_SRC
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::16][udwt.jl:16]], [[FfZly5es][back to index]]
 :END:

*** UDWT Available Filters

For the moment this is just for demonstration, more filters will be
added in the future.

 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="UDWT_Filter_Available",tag_to_ignore="Internal",header_level=0,case_sensitive=true)
 #+END_SRC

 #+RESULTS:
 :RESULTS:

 <<Ik790JDf>> *Index:* *[U]* [[WTvaLRSo][UDWT_Filter_Haar]], [[0m8aamVm][UDWT_Filter_Starck2]] 
 - @@latex:\phantomsection@@ *=UDWT_Filter_Haar=*  <<WTvaLRSo>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Haar{T<:AbstractFloat} <: UDWT_Filter{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Haar filter
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::47][udwt.jl:47]], [[Ik790JDf][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT_Filter_Haar{T}() where {T<:Real}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::53][udwt.jl:53]], [[Ik790JDf][back to index]]
 - @@latex:\phantomsection@@ *=UDWT_Filter_Starck2=*  <<0m8aamVm>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT_Filter_Starck2{T<:AbstractFloat} <: UDWT_Filter_Biorthogonal{T}
 #+END_SRC
 #+BEGIN_QUOTE
 Starck2 filter

 Defined by Eq. 6 from http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4060954
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::61][udwt.jl:61]], [[Ik790JDf][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT_Filter_Starck2{T}() where {T<:Real}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::71][udwt.jl:71]], [[Ik790JDf][back to index]]
 :END:


*** UDWT Computational subroutines
 #+BEGIN_SRC julia :results output drawer :eval no-export :exports results
print_org_doc(documented_items,tag="UDWT",tag_to_ignore="Internal",header_level=0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 <<xedvfd9x>> *Index:* *[U]* [[Z4RKSi49][UDWT]] *[i]* [[i5ZfTS2c][inverse_udwt]], [[STSKJJfb][inverse_udwt!]] *[l]* [[70HIQs2j][length]] *[s]* [[8sXRoEMX][scale]] *[u]* [[NO2g5na8][udwt]] 
 - @@latex:\phantomsection@@ *=UDWT=*  <<Z4RKSi49>>
 #+BEGIN_SRC julia :eval never :exports code
 struct UDWT{T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 A structure to store 1D UDWT
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::80][udwt.jl:80]], [[xedvfd9x][back to index]]

 #+BEGIN_SRC julia :eval never :exports code
 UDWT{T}(filter::UDWT_Filter_Biorthogonal{T};
	     n::Int=0,
	     scale::Int=0) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Creates an instance

 *Parameters:*
 - *filter*: used filter
 - *scale* : max scale
 - *n*: signal length
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::91][udwt.jl:91]], [[xedvfd9x][back to index]]
 - @@latex:\phantomsection@@ *=inverse_udwt=*  <<i5ZfTS2c>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt(udwt_domain::UDWT{T})::Array{T,1} where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Returns:* a vector containing the reconstructed signal.
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::234][udwt.jl:234]], [[xedvfd9x][back to index]]
 - @@latex:\phantomsection@@ *=inverse_udwt!=*  <<STSKJJfb>>
 #+BEGIN_SRC julia :eval never :exports code
 function inverse_udwt!(udwt_domain::UDWT{T},
			reconstructed_signal::AbstractArray{T,1}) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D *inverse* undecimated wavelet transform

 *Caveat:* uses a pre-allocated vector =reconstructed_signal=
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::176][udwt.jl:176]], [[xedvfd9x][back to index]]
 - @@latex:\phantomsection@@ *=length=*  <<70HIQs2j>>
 #+BEGIN_SRC julia :eval never :exports code
 length(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns expected signal length
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::110][udwt.jl:110]], [[xedvfd9x][back to index]]
 - @@latex:\phantomsection@@ *=scale=*  <<8sXRoEMX>>
 #+BEGIN_SRC julia :eval never :exports code
 scale(udwt::UDWT)::Int
 #+END_SRC
 #+BEGIN_QUOTE
 Returns max scale
 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::107][udwt.jl:107]], [[xedvfd9x][back to index]]
 - @@latex:\phantomsection@@ *=udwt=*  <<NO2g5na8>>
 #+BEGIN_SRC julia :eval never :exports code
 function udwt(signal::AbstractArray{T,1},
	       filter::UDWT_Filter_Biorthogonal{T};
	       scale::Int=3) where {T<:Number}
 #+END_SRC
 #+BEGIN_QUOTE
 Performs an 1D undecimated wavelet transform

 $$(\mathcal{W}_{j+1}f)[u]=(\bar{g}_j*\mathcal{V}_{j}f)[u]$$
 $$(\mathcal{V}_{j+1}f)[u]=(\bar{h}_j*\mathcal{V}_{j}f)[u]$$

 #+END_QUOTE
 [[file:/home/picaud/GitHub/DirectConvolution.jl/src/udwt.jl::114][udwt.jl:114]], [[xedvfd9x][back to index]]
 :END:




* Unit tests

#+BEGIN_SRC julia :results output table :exports results
include("/home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl")
#+END_SRC

#+RESULTS:
#+begin_example
Convolution commutativity: Error During Test
  Got an exception of type MethodError outside of a @test
  MethodError: no method matching directConv!(::DirectConvolution.LinearFilter_Default{Float64,4}, ::Int64, ::Array{Float64,1}, ::Array{Float64,1}, ::UnitRange{Int64}, ::Type{DirectConvolution.ZeroPaddingBE}, ::Type{DirectConvolution.ZeroPaddingBE})
  Closest candidates are:
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension} at none:17
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{min_J_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension, min_J_BE<:DirectConvolution.BoundaryExtension} at none:17
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{min_J_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{max_J_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension, min_J_BE<:DirectConvolution.BoundaryExtension, max_J_BE<:DirectConvolution.BoundaryExtension} at none:17
    ...
  Stacktrace:
   [1] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/directConvolution.jl:43 [inlined]
   [2] macro expansion at ./test.jl:860 [inlined]
   [3] anonymous at ./<missing>:?
   [4] include_from_node1(::String) at ./loading.jl:576
   [5] include(::String) at ./sysimg.jl:14
   [6] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl:10 [inlined]
   [7] macro expansion at ./test.jl:860 [inlined]
   [8] anonymous at ./<missing>:?
   [9] include_from_node1(::String) at ./loading.jl:576
   [10] include(::String) at ./sysimg.jl:14
   [11] eval(::Module, ::Any) at ./boot.jl:235
   [12] eval_user_input(::Any, ::Base.REPL.REPLBackend) at ./REPL.jl:66
   [13] macro expansion at /home/picaud/.julia/v0.6/Revise/src/Revise.jl:775 [inlined]
   [14] (::Revise.##17#18{Base.REPL.REPLBackend})() at ./event.jl:73
Interval split: Error During Test
  Got an exception of type MethodError outside of a @test
  MethodError: no method matching directConv!(::DirectConvolution.LinearFilter_Default{Float64,4}, ::Int64, ::Array{Float64,1}, ::Array{Float64,1}, ::UnitRange{Int64}, ::Type{DirectConvolution.MirrorBE}, ::Type{DirectConvolution.PeriodicBE})
  Closest candidates are:
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension} at none:17
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{min_J_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension, min_J_BE<:DirectConvolution.BoundaryExtension} at none:17
    directConv!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::DirectConvolution.LinearFilter{T<:Number}, !Matched::Int64, !Matched::AbstractArray{T<:Number,2}, ::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, ::Type{max_I_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{min_J_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{max_J_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension, min_J_BE<:DirectConvolution.BoundaryExtension, max_J_BE<:DirectConvolution.BoundaryExtension} at none:17
    ...
  Stacktrace:
   [1] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/directConvolution.jl:61 [inlined]
   [2] macro expansion at ./test.jl:860 [inlined]
   [3] anonymous at ./<missing>:?
   [4] include_from_node1(::String) at ./loading.jl:576
   [5] include(::String) at ./sysimg.jl:14
   [6] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl:10 [inlined]
   [7] macro expansion at ./test.jl:860 [inlined]
   [8] anonymous at ./<missing>:?
   [9] include_from_node1(::String) at ./loading.jl:576
   [10] include(::String) at ./sysimg.jl:14
   [11] eval(::Module, ::Any) at ./boot.jl:235
   [12] eval_user_input(::Any, ::Base.REPL.REPLBackend) at ./REPL.jl:66
   [13] macro expansion at /home/picaud/.julia/v0.6/Revise/src/Revise.jl:775 [inlined]
   [14] (::Revise.##17#18{Base.REPL.REPLBackend})() at ./event.jl:73
2D convolution: Error During Test
  Got an exception of type MethodError outside of a @test
  MethodError: no method matching directConv2D!(::DirectConvolution.LinearFilter_DefaultCentered{Int64,3}, ::Int64, ::DirectConvolution.LinearFilter_DefaultCentered{Int64,5}, ::Int64, ::Array{Float64,2})
  Closest candidates are:
    directConv2D!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, ::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::AbstractArray{T<:Number,2}) where T<:Number at /home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl:410
    directConv2D!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, ::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::AbstractArray{T<:Number,2}, !Matched::Type{min_I_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension} at /home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl:410
    directConv2D!(::DirectConvolution.LinearFilter{T<:Number}, ::Int64, ::DirectConvolution.LinearFilter{T<:Number}, ::Int64, !Matched::AbstractArray{T<:Number,2}, !Matched::Type{min_I_BE<:DirectConvolution.BoundaryExtension}, !Matched::Type{max_I_BE<:DirectConvolution.BoundaryExtension}) where {T<:Number, min_I_BE<:DirectConvolution.BoundaryExtension, max_I_BE<:DirectConvolution.BoundaryExtension} at /home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl:410
    ...
  Stacktrace:
   [1] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/directConvolution.jl:75 [inlined]
   [2] macro expansion at ./test.jl:860 [inlined]
   [3] anonymous at ./<missing>:?
   [4] include_from_node1(::String) at ./loading.jl:576
   [5] include(::String) at ./sysimg.jl:14
   [6] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl:10 [inlined]
   [7] macro expansion at ./test.jl:860 [inlined]
   [8] anonymous at ./<missing>:?
   [9] include_from_node1(::String) at ./loading.jl:576
   [10] include(::String) at ./sysimg.jl:14
   [11] eval(::Module, ::Any) at ./boot.jl:235
   [12] eval_user_input(::Any, ::Base.REPL.REPLBackend) at ./REPL.jl:66
   [13] macro expansion at /home/picaud/.julia/v0.6/Revise/src/Revise.jl:775 [inlined]
   [14] (::Revise.##17#18{Base.REPL.REPLBackend})() at ./event.jl:73
Test Summary:                  | Pass  Error  Total
DirectConvolution              |   34      3     37
  swap                         |    4             4
  LinearFilter_DefaultCentered |    3             3
  LinearFilter_Default         |    4             4
  Example α_offset             |    2             2
  Adjoint operator             |    2             2
  Convolution commutativity    |           1      1
  Interval split               |           1      1
  2D convolution               |           1      1
  Savitzky-Golay               |    6             6
  Haar                         |    4             4
  Starck2                      |    1             1
  UDWT Transform               |    8             8
ERROR: LoadError: Some tests did not pass: 34 passed, 0 failed, 3 errored, 0 broken.
while loading /home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl, in expression starting on line 4
#+end_example

* Internal documentation :noexport:

#+BEGIN_SRC julia :results output drawer :eval no-export :exports results
documented_items=create_documented_item_array_dir("~/GitHub/DirectConvolution.jl/src/");
print_org_doc(documented_items,tag="Internal",header_level=0,complete_link=true)
#+END_SRC

#+RESULTS:
:RESULTS:

<<yt1lT5aS>> *Index:* *[L]* [[JZ4X2zVS][LinearFilter_Default]], [[PxBRjx8I][LinearFilter_DefaultCentered]] *[b]* [[VHDkYavH][boundaryExtension]] *[c]* [[HAoKsL5U][compute_Ωγ1]] *[d]* [[y73ifjkh][directConv!]] *[f]* [[wMc8ycai][filter_range]] *[i]* [[1gYj5nTl][isapprox]] *[o]* [[y9TGY1PF][offset]] *[r]* [[XSzELJFG][range]], [[CpZN0P0A][relativeComplement_left]], [[fQkwp3qG][relativeComplement_right]] *[s]* [[P4776uRu][scale]] 
- @@latex:\phantomsection@@ *=LinearFilter_Default=*  <<JZ4X2zVS>>
#+BEGIN_SRC julia :eval never :exports code
struct LinearFilter_Default{T<:Number,N} <: LinearFilter{T}
#+END_SRC
#+BEGIN_QUOTE
Default linear filter
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::53][linearFilter.jl:53]], [[yt1lT5aS][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function LinearFilter_Default(c::AbstractArray{T,1},offset::Int)  where {T<:Number}
#+END_SRC
#+BEGIN_QUOTE
Creates a linear filter from a coefficient vector and its associated offset

*Example:*
#+BEGIN_SRC julia
linear_filter=LinearFilter(rand(3),5)
offset(linear_filter)
range(linear_filter)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
DirectConvolution.LinearFilter_Default{Float64,3}([0.945074, 0.186933, 0.542954], 5)
5
-5:-3
#+END_SRC

#+RESULTS:
| -5 |
| -4 |
| -3 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::62][linearFilter.jl:62]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=LinearFilter_DefaultCentered=*  <<PxBRjx8I>>
#+BEGIN_SRC julia :eval never :exports code
struct LinearFilter_DefaultCentered{T<:Number,N} <: LinearFilter{T}
#+END_SRC
#+BEGIN_QUOTE
Default *centered* linear filter

Array length has to be odd, 2n+1. Filter offset is n by construction.
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::77][linearFilter.jl:77]], [[yt1lT5aS][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function LinearFilter_DefaultCentered(c::AbstractArray{T,1}) where {T<:Number}
#+END_SRC
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::87][linearFilter.jl:87]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=boundaryExtension=*  <<VHDkYavH>>
#+BEGIN_SRC julia :eval never :exports code
function boundaryExtension(β::AbstractArray{T,1},
                           k::Int,
                           ::Type{ZeroPaddingBE}) where {T <: Number}
#+END_SRC
#+BEGIN_QUOTE
#+BEGIN_SRC julia
r=-5:10
hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,ZeroPaddingBE),r))'
#+END_SRC

#+RESULTS:
| -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|  0 |  0 |  0 |  0 |  0 | 0 | 1 | 2 | 3 | 0 | 0 | 0 | 0 | 0 | 0 |  0 |

#+BEGIN_SRC julia
-5:10
2×16 Array{Int64,2}:
 -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
  0   0   0   0   0  0  1  2  3  0  0  0  0  0  0   0
#+END_SRC

#+RESULTS:
| -5 |
| -4 |
| -3 |
| -2 |
| -1 |
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::109][directConvolution.jl:109]], [[yt1lT5aS][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function boundaryExtension(β::AbstractArray{T,1},
                           k::Int,
                           ::Type{ConstantBE}) where {T <: Number}
#+END_SRC
#+BEGIN_QUOTE
#+BEGIN_SRC julia
r=-5:10
hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,ConstantBE),r))'
#+END_SRC

#+RESULTS:
| -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|  1 |  1 |  1 |  1 |  1 | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |  3 |

#+BEGIN_SRC julia
-5:10
2×16 Array{Int64,2}:
 -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
  1   1   1   1   1  1  1  2  3  3  3  3  3  3  3   3
#+END_SRC

#+RESULTS:
| -5 |
| -4 |
| -3 |
| -2 |
| -1 |
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::127][directConvolution.jl:127]], [[yt1lT5aS][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function boundaryExtension(β::AbstractArray{T,1},
                           k::Int,
                           ::Type{PeriodicBE}) where {T <: Number}
#+END_SRC
#+BEGIN_QUOTE
#+BEGIN_SRC julia
r=-5:10
hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,PeriodicBE),r))'
#+END_SRC

#+RESULTS:
| -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|  1 |  2 |  3 |  1 |  2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 |  1 |

#+BEGIN_SRC julia
-5:10
2×16 Array{Int64,2}:
 -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
  1   2   3   1   2  3  1  2  3  1  2  3  1  2  3   1
#+END_SRC

#+RESULTS:
| -5 |
| -4 |
| -3 |
| -2 |
| -1 |
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::147][directConvolution.jl:147]], [[yt1lT5aS][back to index]]

#+BEGIN_SRC julia :eval never :exports code
function boundaryExtension(β::AbstractArray{T,1},
                           k::Int,
                           ::Type{MirrorBE}) where {T <: Number}
#+END_SRC
#+BEGIN_QUOTE
#+BEGIN_SRC julia
r=-5:10
hcat(r,map(x->DirectConvolution.boundaryExtension([1:3;],x,MirrorBE),r))'
#+END_SRC

#+RESULTS:
| -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|  3 |  2 |  1 |  2 |  3 | 2 | 1 | 2 | 3 | 2 | 1 | 2 | 3 | 2 | 1 |  2 |

#+BEGIN_SRC julia
-5:10
2×16 Array{Int64,2}:
 -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10
  3   2   1   2   3  2  1  2  3  2  1  2  3  2  1   2
#+END_SRC

#+RESULTS:
| -5 |
| -4 |
| -3 |
| -2 |
| -1 |
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::161][directConvolution.jl:161]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=compute_Ωγ1=*  <<HAoKsL5U>>
#+BEGIN_SRC julia :eval never :exports code
function compute_Ωγ1(Ωα::UnitRange{Int},
                     λ::Int,
                     Ωβ::UnitRange{Int})
#+END_SRC
#+BEGIN_QUOTE
In
$$
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
$$
the computation of $\gamma[k],\ k\in\Omega^\gamma$ is splitted into two parts:  
 - one part $\Omega^\gamma \cap \Omega^\gamma_1$ *free of boundary effect*,  
 - one part $\Omega^\gamma \setminus \Omega^\gamma_1$ *that requires boundary extension* $\tilde{\beta}=\Phi(\beta,k)$

*Example:*
#+BEGIN_SRC julia
DirectConvolution.compute_Ωγ1(-1:2,-2,1:20)
#+END_SRC

#+RESULTS:
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |

#+BEGIN_SRC julia
5:18
#+END_SRC

#+RESULTS:
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::47][directConvolution.jl:47]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=directConv!=*  <<y73ifjkh>>
#+BEGIN_SRC julia :eval never :exports code
function directConv!(tilde_α::AbstractArray{T,1},
                     α_offset::Int,
                     λ::Int,
                     β::AbstractArray{T,1},
                     γ::AbstractArray{T,1},
                     Ωγ::UnitRange{Int},
                     ::Type{LeftBE}=ZeroPaddingBE,
                     ::Type{RightBE}=ZeroPaddingBE;
                     accumulate::Bool=false)::Void where {T <: Number,
                                                          LeftBE <: BoundaryExtension,
                                                          RightBE <: BoundaryExtension}
#+END_SRC
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::178][directConvolution.jl:178]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=filter_range=*  <<wMc8ycai>>
#+BEGIN_SRC julia :eval never :exports code
filter_range(size::Int,offset::Int)::UnitRange
#+END_SRC
#+BEGIN_QUOTE
Computes [[sh4Kw0RIrange_filter][range(...)]] using primitive types.
This allows reuse by =directConv!= for instance.

*Caveat:* do not overload Base.range !!! 
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::28][linearFilter.jl:28]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=isapprox=*  <<1gYj5nTl>>
#+BEGIN_SRC julia :eval never :exports code
function isapprox(f::LinearFilter{T},v::AbstractArray{T,1}) where {T<:Number}
#+END_SRC
#+BEGIN_QUOTE
For convenience only, used in utests
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::45][linearFilter.jl:45]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=offset=*  <<y9TGY1PF>>
#+BEGIN_SRC julia :eval never :exports code
offset(f::LinearFilter_DefaultCentered{T,N}) where {T<:Number,N}
#+END_SRC
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::94][linearFilter.jl:94]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=range=*  <<XSzELJFG>> <<sh4Kw0RIrange_filter>>
#+BEGIN_SRC julia :eval never :exports code
range(c::LinearFilter)::UnitRange
#+END_SRC
#+BEGIN_QUOTE
Returns filter range $\Omega$

Filter support is defined by
$$
\Omega_\alpha = [ -\text{offset}(\alpha) , \text{size}(\alpha) -\text{offset}(\alpha)  - 1 ]
$$
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/linearFilter.jl::36][linearFilter.jl:36]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=relativeComplement_left=*  <<CpZN0P0A>>
#+BEGIN_SRC julia :eval never :exports code
function relativeComplement_left(A::UnitRange{Int},
                                 B::UnitRange{Int})
#+END_SRC
#+BEGIN_QUOTE
Left relative complement

$$
(A\setminus B)_{\text{Left}}=[  l(A), \min{(u(A),l(B)-1)} ]
$$

*Example:*
#+BEGIN_SRC julia
DirectConvolution.relativeComplement_left(1:10,-5:5)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
1:0
#+END_SRC

#+RESULTS:

$(A\setminus B)=\{6,7,8,9,10\}$ and the left part (elements that are
$\in A$ but on the left side of $B$) is *empty*.
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::69][directConvolution.jl:69]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=relativeComplement_right=*  <<fQkwp3qG>>
#+BEGIN_SRC julia :eval never :exports code
function relativeComplement_right(A::UnitRange{Int},
                                  B::UnitRange{Int})
#+END_SRC
#+BEGIN_QUOTE
Left relative complement

$$
(A\setminus B)_{\text{Right}}=[ \max{(l(A),u(B)+1)}, u(A) ]
$$

*Example:*
#+BEGIN_SRC julia
DirectConvolution.relativeComplement_right(1:10,-5:5)
#+END_SRC

#+RESULTS:
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

#+BEGIN_SRC julia
6:10
#+END_SRC

#+RESULTS:
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

$(A\setminus B)=\{6,7,8,9,10\}$ and the right part (elements that are
$\in A$ but on the right side of $B$) is $\{6,7,8,9,10\}$
#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::88][directConvolution.jl:88]], [[yt1lT5aS][back to index]]
- @@latex:\phantomsection@@ *=scale=*  <<P4776uRu>>
#+BEGIN_SRC julia :eval never :exports code
function scale(λ::Int,Ω::UnitRange{Int})
#+END_SRC
#+BEGIN_QUOTE
Range scaling

*Caveat:*
We do not use Julia =*= operator as it returns a step range:
#+BEGIN_SRC julia
r=6:8
-2*r
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia
6:8
-12:-2:-16
#+END_SRC

#+RESULTS:
| -12 |
| -14 |
| -16 |

What we need is:
#+BEGIN_SRC julia
scale(-2,r)
#+END_SRC

#+RESULTS:
| -16 |
| -15 |
| -14 |
| -13 |
| -12 |

#+BEGIN_SRC julia
-16:-12
#+END_SRC

#+RESULTS:
| -16 |
| -15 |
| -14 |
| -13 |
| -12 |

#+END_QUOTE
[[file:/home/picaud/GitHub/DirectConvolution.jl/src/directConvolution.jl::30][directConvolution.jl:30]], [[yt1lT5aS][back to index]]
:END:
