#+TITLE: Direct Convolution Package
#+PROPERTY: header-args:julia :session *doc_session* :eval no-export 
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmonofont{DejaVu Sans Mono}[Scale=MatchLowercase]

#+STYLE: :width=200

#+RESULTS:
#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}\setminted[julia]{
  bgcolor=bg,
  breaklines=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

* Introduction

*Under construction do not use!*

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

using direct (no FFT) methods. 

We provide the
- [[id:59e21a70-6395-4a06-9979-8e4449ac4c64][=directConv!=]] 
- [[id:093c1821-7217-46fb-9e1b-1a397554fa0e][=directConv=]]
functions.

Eq. \ref{eq:main} has several applications:
- [[id:e51770f6-45da-4051-b6ab-d0835187f438][Savitzky-Golay filters]] 
- [[id:32475da6-a0b9-4103-a58f-04eebdb75785][Undecimated Wavelet Transform]]

* Usage examples

#+BEGIN_SRC julia
using Plots
using DirectConvolution
#+END_SRC

#+RESULTS:

** Savitzky-Golay filters
   :PROPERTIES:
   :ID:       e51770f6-45da-4051-b6ab-d0835187f438
   :END:

Creates a set of Savitzky-Golay filters, window width is $11=2*5+1$ and polynomial degree is $3$.

#+BEGIN_SRC julia
sg = SG_Filter(Float64,halfWidth=5,degree=3)
#+END_SRC

#+RESULTS:

This can be checked with

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
length(sg)
polynomialOrder(sg)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
11
3
#+END_SRC

Savitzky-Golay filters can be used to smooth or to compute smoothed
derivatives of a signal. The associated filter is obtained thanks to
the =filter= function.

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
filter(sg,derivativeOrder=2)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
DirectConvolution.SavitzkyGolay_Filter{Float64,11}([0.034965, 0.013986, -0.002331, -0.013986, -0.020979, -0.02331, -0.020979, -0.013986, -0.002331, 0.013986, 0.034965])
#+END_SRC

Maximum derivative order is equal to the polynomial order, however there is a dedicated function:

#+BEGIN_SRC julia :exports both :wrap "SRC julia :exports code :eval never" :results output
maxDerivativeOrder(sg)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia :exports code :eval never
3
#+END_SRC

Smoothing example:

#+BEGIN_SRC julia
smoothed=directConv(filter(sg,derivativeOrder=0),signal,ConstantBE,ConstantBE)

plot(signal,label="signal")
plot!(smoothed, label="smoothed",linewidth=2)
plot!(signal-smoothed, label="residue")
#+END_SRC

#+RESULTS:


#+BEGIN_SRC julia :results graphics :file figures/sg.png :exports results
savefig("figures/sg.png")
#+END_SRC

#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothing
#+RESULTS:
[[file:figures/sg.png]]


Smoothed first order derivative example:

#+BEGIN_SRC julia
smoothed_d1 = directConv(filter(sg,derivativeOrder=1),signal)

plot(signal,label="signal")
plot!(smoothed_d1, label="smoothed derivative",linewidth=2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia :results graphics :file figures/sg_d1.png :exports results
savefig("figures/sg_d1.png")
#+END_SRC


#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothed first order derivative
#+RESULTS:
[[file:figures/sg_d1.png]]


** Undecimated Wavelet Transform
   :PROPERTIES:
   :ID:       32475da6-a0b9-4103-a58f-04eebdb75785
   :END:

* Code documentation

** Linear filter

There is nothing fundamental here. We only define a convenience
wrapper to store filter coefficients and an [[id:bc38afbb-e108-4e1b-8f88-4026f9f5e860][offset]] used to define
filter support.
The wrapper is an abstract type:

#+CALL: Julia_Extract_Snippet("../src/linearFilter.jl","AbstractLinearFilter")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
abstract type LinearFilter{T<:Number} end

#+END_SRC

User must define these methods:

#+CALL: Julia_Extract_Snippet("../src/linearFilter.jl","AbstractLinearFilterMethods")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
fcoef(c::LinearFilter) = c._fcoef
Base.length(c::LinearFilter) = length(fcoef(c))
offset(c::LinearFilter) = c._offset
Base.range(c::LinearFilter) = UnitRange(-offset(c),length(c)-offset(c)-1)

#+END_SRC

By default, the structure is assumed to have two fields: *_filter* and
*_offset*. However, if you do not want that, simply overload the
associated method.

*** Filter coefficient array

By default the *_filter_coef* field. For efficiency you can use StaticArrays.

*** Offset and support 
    :PROPERTIES:
    :ID:       bc38afbb-e108-4e1b-8f88-4026f9f5e860
    :END:

Filter coefficient array also defines the number of coefficients, hence
to define filter support $\Omega_\alpha$ one only needs an additional
offset.

The filter support is defined as follows:

$$
\Omega_\alpha = [ -\text{offset},\text{length}-\text{offset} -1 ]
$$

** Convolution functions

These are the main functions of the package, allowing to compute Eq. \ref{eq:main}.

*** =directConv!=
    :PROPERTIES:
    :ID:       59e21a70-6395-4a06-9979-8e4449ac4c64
    :END:

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","directConv!")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv!(tilde_α::AbstractArray{T,1},
                     α_offset::Int,
                     λ::Int,

                     β::AbstractArray{T,1},

                     γ::AbstractArray{T,1},
                     Ωγ::UnitRange{Int},
                     
                     ::Type{LeftBE}=ZeroPaddingBE,
                     ::Type{RightBE}=ZeroPaddingBE;
                     
                     accumulate::Bool=false) where {T <: Number,
                                                    LeftBE <: BoundaryExtension,
                                                    RightBE <: BoundaryExtension}
    
#+END_SRC

*** =directConv=
    :PROPERTIES:
    :ID:       093c1821-7217-46fb-9e1b-1a397554fa0e
    :END:

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","directConv")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv(tilde_α::AbstractArray{T,1},
                    α_offset::Int64,
                    λ::Int64,

                    β::AbstractArray{T,1},

                    ::Type{LeftBE}=ZeroPaddingBE,
                    ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
                                                          LeftBE <: BoundaryExtension,
                                                          RightBE <: BoundaryExtension}
    
#+END_SRC

*** =BoundaryExtension= 
    :PROPERTIES:
    :ID:       04564489-bd48-4d43-b56e-7f93e200a86d
    :END:

Used to define boundary extensions.

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","BoundaryExtension")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
abstract type BoundaryExtension end

struct ZeroPaddingBE <: BoundaryExtension end
struct ConstantBE <: BoundaryExtension end
struct PeriodicBE <: BoundaryExtension end
struct MirrorBE <: BoundaryExtension end

#+END_SRC


* UTest

#+BEGIN_SRC sh :eval no-export :exports results :results output :wrap "EXAMPLE"
julia ../test/runtests.jl
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Test Summary:     | Pass  Total
DirectConvolution |   35     35
#+END_EXAMPLE

* TODO [0/1]

- [ ] change filter -> coefficient
- [ ] add example with derivative taking X into account

