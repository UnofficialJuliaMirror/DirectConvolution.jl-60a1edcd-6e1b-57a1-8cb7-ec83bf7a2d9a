#+TITLE: Direct Convolution Package
#+PROPERTY: header-args:julia :session *doc_session* :eval no-export 
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmonofont{DejaVu Sans Mono}[Scale=MatchLowercase]

#+STYLE: :width=200

#+RESULTS:
#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}\setminted[julia]{
  bgcolor=bg,
  breaklines=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

* Introduction

*Under construction do not use!*

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

using direct (no FFT) methods. 

We provide the
- [[id:59e21a70-6395-4a06-9979-8e4449ac4c64][=directConv!=]] 
- [[id:093c1821-7217-46fb-9e1b-1a397554fa0e][=directConv=]]
functions.

Eq. \ref{eq:main} has several applications:
- [[id:e51770f6-45da-4051-b6ab-d0835187f438][Savitzky-Golay filters]] 
- [[id:32475da6-a0b9-4103-a58f-04eebdb75785][Undecimated Wavelet Transform]]

* Usage examples

#+BEGIN_SRC julia
using Plots
using Revise
using DirectConvolution
#+END_SRC

#+RESULTS:

** Savitzky-Golay filters
   :PROPERTIES:
   :ID:       e51770f6-45da-4051-b6ab-d0835187f438
   :END:

Creates a set of Savitzky-Golay filters, window width is $11=2*5+1$ and polynomial degree is $3$.

#+BEGIN_SRC julia
sg = SG_Filter(Float64,halfWidth=5,degree=3)
#+END_SRC

#+RESULTS:

This can be checked with

#+BEGIN_SRC julia
length(sg)
polynomialOrder(sg)
#+END_SRC

#+RESULTS:
: 3

Savitzky-Golay filters can be used to smooth or to compute smoothed
derivatives of a signal. The associated filter is obtained thanks to
the =filter= function.

#+BEGIN_SRC julia
# $\int sin(x) dx$
filter(sg,derivativeOrder=2)
#+END_SRC

#+RESULTS:

Maximum derivative order is equal to the polynomial order, however there is a dedicated function:

#+BEGIN_SRC julia
maxDerivativeOrder(sg)
#+END_SRC

#+RESULTS:
: 3

Smoothing example:

#+BEGIN_SRC julia
smoothed   =directConv(filter(sg,derivativeOrder=0),signal,ConstantBE,ConstantBE)

plot(signal,label="signal")
plot!(smoothed, label="smoothed",linewidth=2)
plot!(signal-smoothed, label="residue")
#+END_SRC

#+RESULTS:


#+BEGIN_SRC julia :results graphics :file figures/sg.png :exports results
savefig("figures/sg.png")
#+END_SRC

#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothing
#+RESULTS:
[[file:figures/sg.png]]


Smoothed first order derivative example:

#+BEGIN_SRC julia
smoothed_d1 = directConv(filter(sg,derivativeOrder=1),signal)

plot(signal,label="signal")
plot!(smoothed_d1, label="smoothed derivative",linewidth=2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC julia :results graphics :file figures/sg_d1.png :exports results
savefig("figures/sg_d1.png")
#+END_SRC


#+ATTR_HTML: :align center :width 600px
#+CAPTION: Savitzky-Golay smoothed first order derivative
#+RESULTS:
[[file:figures/sg_d1.png]]


** Undecimated Wavelet Transform
   :PROPERTIES:
   :ID:       32475da6-a0b9-4103-a58f-04eebdb75785
   :END:

* Code documentation

** Linear filter

There is nothing fundamental here. We only define a convenience
wrapper to store filter coefficients and an [[id:bc38afbb-e108-4e1b-8f88-4026f9f5e860][offset]] used to define
filter support

The wrapper is an abstract type:
#+CALL: Julia_Extract_Snippet("../src/linearFilter.jl","AbstractLinearFilter")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
abstract type LinearFilter{T<:Number} end

#+END_SRC

User must define these methods:

#+CALL: Julia_Extract_Snippet("../src/linearFilter.jl","AbstractLinearFilterMethods")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
Base.filter(c::LinearFilter) = c._filter
Base.length(c::LinearFilter) = length(filter(c))
offset(c::LinearFilter) = c._offset
Base.range(c::LinearFilter) = UnitRange(-offset(c),length(c)-offset(c)-1)

#+END_SRC

By default, the structure is assumed to have two fields: *_filter* and
*_offset*. However, if you do not want that, simply overload the
associated method.

*** Filter coefficient array

By default the *_filter_coef* field. For efficiency you can use StaticArrays.

*** Offset and support 
    :PROPERTIES:
    :ID:       bc38afbb-e108-4e1b-8f88-4026f9f5e860
    :END:

Filter coefficient array also defines the number of coefficients, hence
to define filter support $\Omega_\alpha$ one only needs an additional
offset.

The filter support is defined as follows:

$$
\Omega_\alpha = [ -\text{offset},\text{length}-\text{offset} -1 ]
$$

** Convolution functions

These are the main functions of the package, allowing to compute Eq. \ref{eq:main}.

*** =directConv!=
    :PROPERTIES:
    :ID:       59e21a70-6395-4a06-9979-8e4449ac4c64
    :END:

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","directConv!")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv!(tilde_α::AbstractArray{T,1},
                     α_offset::Int,
                     λ::Int,

                     β::AbstractArray{T,1},

                     γ::AbstractArray{T,1},
                     Ωγ::UnitRange{Int},
                     
                     ::Type{LeftBE}=ZeroPaddingBE,
                     ::Type{RightBE}=ZeroPaddingBE;
                     
                     accumulate::Bool=false) where {T <: Number,
                                                    LeftBE <: BoundaryExtension,
                                                    RightBE <: BoundaryExtension}
    
#+END_SRC

*** =directConv=
    :PROPERTIES:
    :ID:       093c1821-7217-46fb-9e1b-1a397554fa0e
    :END:

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","directConv")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv(tilde_α::AbstractArray{T,1},
                    α_offset::Int64,
                    λ::Int64,

                    β::AbstractArray{T,1},

                    ::Type{LeftBE}=ZeroPaddingBE,
                    ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
                                                          LeftBE <: BoundaryExtension,
                                                          RightBE <: BoundaryExtension}
    
#+END_SRC

*** =BoundaryExtension= 
    :PROPERTIES:
    :ID:       04564489-bd48-4d43-b56e-7f93e200a86d
    :END:

Used to define boundary extensions.

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","BoundaryExtension")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
abstract type BoundaryExtension end

struct ZeroPaddingBE <: BoundaryExtension end
struct ConstantBE <: BoundaryExtension end
struct PeriodicBE <: BoundaryExtension end
struct MirrorBE <: BoundaryExtension end

#+END_SRC


* UTest

#+BEGIN_SRC julia :exports results :results output
include("../test/runtests.jl")
#+END_SRC

#+RESULTS:
#+begin_example
Savitzky-Golay: Error During Test
  Test threw an exception of type MethodError
  Expression: filter(m, derivativeOrder=0) ≈ [1 / 5; 1 / 5; 1 / 5; 1 / 5; 1 / 5]
  MethodError: no method matching isapprox(::DirectConvolution.SavitzkyGolay_Filter{Float64,5}, ::Array{Float64,1})
  Closest candidates are:
    isapprox(!Matched::AbstractArray, ::AbstractArray; rtol, atol, nans, norm) at linalg/generic.jl:1297
  Stacktrace:
   [1] eval_comparison(::Expr, ::Expr) at ./test.jl:198
   [2] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/SG_Filter.jl:12 [inlined]
   [3] macro expansion at ./test.jl:860 [inlined]
   [4] anonymous at ./<missing>:?
Savitzky-Golay: Error During Test
  Test threw an exception of type MethodError
  Expression: filter(m, derivativeOrder=1) ≈ [-(3 / 28); -(1 / 14); -(1 / 28); 0; 1 / 28; 1 / 14; 3 / 28]
  MethodError: no method matching isapprox(::DirectConvolution.SavitzkyGolay_Filter{Float64,7}, ::Array{Float64,1})
  Closest candidates are:
    isapprox(!Matched::AbstractArray, ::AbstractArray; rtol, atol, nans, norm) at linalg/generic.jl:1297
  Stacktrace:
   [1] eval_comparison(::Expr, ::Expr) at ./test.jl:198
   [2] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/SG_Filter.jl:16 [inlined]
   [3] macro expansion at ./test.jl:860 [inlined]
   [4] anonymous at ./<missing>:?
Savitzky-Golay: Error During Test
  Test threw an exception of type MethodError
  Expression: filter(m, derivativeOrder=2) ≈ [5 / 42; 0; -(1 / 14); -(2 / 21); -(1 / 14); 0; 5 / 42]
  MethodError: no method matching isapprox(::DirectConvolution.SavitzkyGolay_Filter{Float64,7}, ::Array{Float64,1})
  Closest candidates are:
    isapprox(!Matched::AbstractArray, ::AbstractArray; rtol, atol, nans, norm) at linalg/generic.jl:1297
  Stacktrace:
   [1] eval_comparison(::Expr, ::Expr) at ./test.jl:198
   [2] macro expansion at /home/picaud/GitHub/DirectConvolution.jl/test/SG_Filter.jl:17 [inlined]
   [3] macro expansion at ./test.jl:860 [inlined]
   [4] anonymous at ./<missing>:?
Test Summary:               | Pass  Error  Total
DirectConvolution           |   32      3     35
  swap                      |    4             4
  Example α_offset          |    2             2
  Adjoint operator          |    2             2
  Convolution commutativity |    1             1
  Interval split            |    1             1
  Savitzky-Golay definition |    3             3
  Savitzky-Golay            |    3      3      6
  Haar                      |    6             6
  Starck2                   |    2             2
  UDWT Transform            |    8             8
ERROR: LoadError: Some tests did not pass: 32 passed, 0 failed, 3 errored, 0 broken.
while loading /home/picaud/GitHub/DirectConvolution.jl/test/runtests.jl, in expression starting on line 4
#+end_example

* TODO [0/1]

- [ ] change filter -> coefficient
- [ ] add example with derivative taking X into account

