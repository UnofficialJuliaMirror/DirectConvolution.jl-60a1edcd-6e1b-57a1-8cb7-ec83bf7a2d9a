#+TITLE: DirectConvolution docs
#+PROPERTY: header-args:julia :session *doc_session* :eval no-export 
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmonofont{DejaVu Sans Mono}[Scale=MatchLowercase]

#+STYLE: :width=200

#+RESULTS:
#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[julia]{
  bgcolor=bg,
  breaklines=true,
  mathescape,
  fontsize=\footnotesize}
#+END_EXPORT

* Introduction

This package goal is to compute convolution products 

\begin{equation}
\label{eq:main}
\gamma[k]=\sum\limits_{i\in\Omega^\alpha}\alpha[i]\beta[k+\lambda i],\text{ with }\lambda\in\mathbb{Z}^*
\end{equation}

using direct (no FFT) methods. 

We provide the
- [[id:59e21a70-6395-4a06-9979-8e4449ac4c64][=directConv!=]] 
- [[id:093c1821-7217-46fb-9e1b-1a397554fa0e][=directConv=]]
functions.

Eq. \ref{eq:main} has several applications:
- [[id:e51770f6-45da-4051-b6ab-d0835187f438][Savitzky-Golay filters]] 
- [[id:32475da6-a0b9-4103-a58f-04eebdb75785][Undecimated Wavelet Transform]]

* Usage examples
** Savitzky-Golay filters
   :PROPERTIES:
   :ID:       e51770f6-45da-4051-b6ab-d0835187f438
   :END:

Creates a set of Savitzky-Golay filters, window width is $11=2*5+1$ and polynomial degree is $3$.

#+BEGIN_SRC julia
sg = SG_Filter(Float64,halfWidth=5,degree=3)
#+END_SRC

This can be checked with

#+BEGIN_SRC julia
length(sg)
polynomialOrder(sg)
#+END_SRC

#+RESULTS:
: 11
: 3

Savitzky-Golay filters can be used to smooth or to compute smoothed
derivatives of a signal. The associated filter is obtained thanks to
the =filter= function.

#+BEGIN_SRC julia
# $\int sin(x) dx$
filter(sg,derivativeOrder=2)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC julia

DirectConvolution.SavitzkyGolay_Filter{Float64,11}([0.034965, 0.013986, -0.002331, -0.013986, -0.020979, -0.02331, -0.020979, -0.013986, -0.002331, 0.013986, 0.034965])
#+END_SRC

Maximum derivative order is equal to the polynomial order, however there is a dedicated function:

#+BEGIN_SRC julia
maxDerivativeOrder(sg)
#+END_SRC

#+RESULTS:
: 3

Smoothing example:

#+BEGIN_SRC julia
smoothed   =directConv(filter(sg,derivativeOrder=0),signal,ConstantBE,ConstantBE)

plot(signal,label="signal")
plot!(smoothed, label="smoothed",linewidth=2)
plot!(signal-smoothed, label="residue")
#+END_SRC



# +ATTR_HTML: :align center :width 
#+CAPTION: Savitzky-Golay smoothing
#+RESULTS:
[[file:figures/sg.png]]







Smoothed first order derivative example:

#+BEGIN_SRC julia
smoothed_d1 = directConv(filter(sg,derivativeOrder=1),signal)

plot(signal,label="signal")
plot!(smoothed_d1, label="smoothed derivative",linewidth=2)
#+END_SRC

#+CAPTION: Savitzky-Golay smoothed first order derivative
#+RESULTS:
[[file:figures/sg_d1.png]]

** Undecimated Wavelet Transform
   :PROPERTIES:
   :ID:       32475da6-a0b9-4103-a58f-04eebdb75785
   :END:

* Code documentation

** Convolution functions

*** =directConv!=
    :PROPERTIES:
    :ID:       59e21a70-6395-4a06-9979-8e4449ac4c64
    :END:

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv!(tilde_α::AbstractArray{T,1},
                     α_offset::Int,
                     λ::Int,

                     β::AbstractArray{T,1},

                     γ::AbstractArray{T,1},
                     Ωγ::UnitRange{Int},
                     
                     ::Type{LeftBE}=ZeroPaddingBE,
                     ::Type{RightBE}=ZeroPaddingBE;
                     
                     accumulate::Bool=false) where {T <: Number,
                                                    LeftBE <: BoundaryExtension,
                                                    RightBE <: BoundaryExtension}
    
#+END_SRC

*** =directConv=
    :PROPERTIES:
    :ID:       093c1821-7217-46fb-9e1b-1a397554fa0e
    :END:

#+CALL: Julia_Extract_Snippet("../src/directConvolution.jl","directConv")

#+RESULTS:
#+BEGIN_SRC julia :eval never :exports code
function directConv(tilde_α::AbstractArray{T,1},
                    α_offset::Int64,
                    λ::Int64,

                    β::AbstractArray{T,1},

                    ::Type{LeftBE}=ZeroPaddingBE,
                    ::Type{RightBE}=ZeroPaddingBE) where {T <: Number,
                                                          LeftBE <: BoundaryExtension,
                                                          RightBE <: BoundaryExtension}
    
#+END_SRC
 
* TODO [0/1]

- [ ] change filter -> coefficient
- [ ] add example with derivative taking X into account

